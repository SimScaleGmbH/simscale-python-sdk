# coding: utf-8

"""
    SimScale API

    The version of the OpenAPI document: 0.0.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from simscale_sdk.configuration import Configuration


class Analysis(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'type': 'str',
        'non_linear_analysis': 'bool',
        'connection_groups': 'list[Contact]',
        'connectors': 'list[PinConnector]',
        'element_technology': 'SolidElementTechnology',
        'model': 'OneOfElectromagneticAnalysisModel',
        'materials': 'list[ElectromagneticMaterial]',
        'initial_conditions': 'SolidInitialConditions',
        'boundary_conditions': 'list[OneOfElectromagneticAnalysisBoundaryConditions]',
        'numerics': 'ElectromagneticNumerics',
        'simulation_control': 'ElectromagneticSimulationControl',
        'result_control': 'ElectromagneticResultControl',
        'mesh_order': 'str',
        'time_dependency': 'OneOfConjugateHeatTransferTimeDependency',
        'inertia_effect': 'str',
        'turbulence_model': 'str',
        'adjoint_turbulence_model': 'str',
        'algorithm': 'str',
        'num_of_passive_species': 'int',
        'enable_adjoint_optimization': 'bool',
        'advanced_concepts': 'AdvancedConcepts',
        'bounding_box_uuid': 'str',
        'material': 'IncompressibleMaterial',
        'flow_domain_boundaries': 'FlowDomainBoundaries',
        'advanced_modelling': 'AdvancedModelling',
        'mesh_settings_new': 'OneOfIncompressiblePacefishMeshSettingsNew',
        'is_compressible': 'bool',
        'is_multiphase': 'bool',
        'number_of_phases': 'int',
        'cavitation_model': 'str',
        'mesh_settings': 'WindComfortMesh',
        'region_of_interest': 'RegionOfInterest',
        'wind_conditions': 'WindConditions',
        'pedestrian_comfort_map': 'list[PedestrianComfortSurface]',
        'additional_result_export': 'FluidResultControls',
        'enable_radiation': 'bool',
        'enable_solar_load': 'bool',
        'enable_humidity_model': 'bool',
        'enable_joule_heating': 'bool',
        'solar_calculator': 'SolarCalculator',
        'contact_handling_mode': 'str',
        'allow_external_flow': 'bool',
        'external_flow_boundary_condition': 'OneOfEmbeddedBoundaryExternalFlowBoundaryCondition',
        'embedded_boundary_meshing': 'EmbeddedBoundaryMeshing',
        'use_local_time_stepping': 'bool',
        'global_physics': 'SolidGlobalPhysics',
        'coils': 'list[Coil]'
    }

    attribute_map = {
        'type': 'type',
        'non_linear_analysis': 'nonLinearAnalysis',
        'connection_groups': 'connectionGroups',
        'connectors': 'connectors',
        'element_technology': 'elementTechnology',
        'model': 'model',
        'materials': 'materials',
        'initial_conditions': 'initialConditions',
        'boundary_conditions': 'boundaryConditions',
        'numerics': 'numerics',
        'simulation_control': 'simulationControl',
        'result_control': 'resultControl',
        'mesh_order': 'meshOrder',
        'time_dependency': 'timeDependency',
        'inertia_effect': 'inertiaEffect',
        'turbulence_model': 'turbulenceModel',
        'adjoint_turbulence_model': 'adjointTurbulenceModel',
        'algorithm': 'algorithm',
        'num_of_passive_species': 'numOfPassiveSpecies',
        'enable_adjoint_optimization': 'enableAdjointOptimization',
        'advanced_concepts': 'advancedConcepts',
        'bounding_box_uuid': 'boundingBoxUuid',
        'material': 'material',
        'flow_domain_boundaries': 'flowDomainBoundaries',
        'advanced_modelling': 'advancedModelling',
        'mesh_settings_new': 'meshSettingsNew',
        'is_compressible': 'isCompressible',
        'is_multiphase': 'isMultiphase',
        'number_of_phases': 'numberOfPhases',
        'cavitation_model': 'cavitationModel',
        'mesh_settings': 'meshSettings',
        'region_of_interest': 'regionOfInterest',
        'wind_conditions': 'windConditions',
        'pedestrian_comfort_map': 'pedestrianComfortMap',
        'additional_result_export': 'additionalResultExport',
        'enable_radiation': 'enableRadiation',
        'enable_solar_load': 'enableSolarLoad',
        'enable_humidity_model': 'enableHumidityModel',
        'enable_joule_heating': 'enableJouleHeating',
        'solar_calculator': 'solarCalculator',
        'contact_handling_mode': 'contactHandlingMode',
        'allow_external_flow': 'allowExternalFlow',
        'external_flow_boundary_condition': 'externalFlowBoundaryCondition',
        'embedded_boundary_meshing': 'embeddedBoundaryMeshing',
        'use_local_time_stepping': 'useLocalTimeStepping',
        'global_physics': 'globalPhysics',
        'coils': 'coils'
    }

    discriminator_value_class_map = {
        'STATIC_ANALYSIS': 'StaticAnalysis',
        'DYNAMIC_ANALYSIS': 'DynamicAnalysis',
        'HEAT_TRANSFER': 'HeatTransfer',
        'THERMAL_MECHANICAL': 'ThermalMechanical',
        'INCOMPRESSIBLE': 'Incompressible',
        'INCOMPRESSIBLE_PACEFISH': 'IncompressiblePacefish',
        'SIMERICS_ANALYSIS': 'SimericsAnalysis',
        'WIND_COMFORT': 'WindComfort',
        'COMPRESSIBLE': 'Compressible',
        'CONVECTIVE_HEAT_TRANSFER': 'ConvectiveHeatTransfer',
        'COUPLED_CONJUGATE_HEAT_TRANSFER': 'CoupledConjugateHeatTransfer',
        'EMBEDDED_BOUNDARY': 'EmbeddedBoundary',
        'MULTIPHASE': 'Multiphase',
        'CONJUGATE_HEAT_TRANSFER': 'ConjugateHeatTransfer',
        'HARMONIC_ANALYSIS': 'HarmonicAnalysis',
        'FREQUENCY_ANALYSIS': 'FrequencyAnalysis',
        'ELECTROMAGNETIC_ANALYSIS': 'ElectromagneticAnalysis'
    }

    def __init__(self, type='ELECTROMAGNETIC_ANALYSIS', non_linear_analysis=None, connection_groups=None, connectors=None, element_technology=None, model=None, materials=None, initial_conditions=None, boundary_conditions=None, numerics=None, simulation_control=None, result_control=None, mesh_order=None, time_dependency=None, inertia_effect=None, turbulence_model=None, adjoint_turbulence_model=None, algorithm=None, num_of_passive_species=None, enable_adjoint_optimization=None, advanced_concepts=None, bounding_box_uuid=None, material=None, flow_domain_boundaries=None, advanced_modelling=None, mesh_settings_new=None, is_compressible=None, is_multiphase=None, number_of_phases=None, cavitation_model=None, mesh_settings=None, region_of_interest=None, wind_conditions=None, pedestrian_comfort_map=None, additional_result_export=None, enable_radiation=None, enable_solar_load=None, enable_humidity_model=None, enable_joule_heating=None, solar_calculator=None, contact_handling_mode=None, allow_external_flow=None, external_flow_boundary_condition=None, embedded_boundary_meshing=None, use_local_time_stepping=None, global_physics=None, coils=None, local_vars_configuration=None):  # noqa: E501
        """Analysis - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._type = None
        self._non_linear_analysis = None
        self._connection_groups = None
        self._connectors = None
        self._element_technology = None
        self._model = None
        self._materials = None
        self._initial_conditions = None
        self._boundary_conditions = None
        self._numerics = None
        self._simulation_control = None
        self._result_control = None
        self._mesh_order = None
        self._time_dependency = None
        self._inertia_effect = None
        self._turbulence_model = None
        self._adjoint_turbulence_model = None
        self._algorithm = None
        self._num_of_passive_species = None
        self._enable_adjoint_optimization = None
        self._advanced_concepts = None
        self._bounding_box_uuid = None
        self._material = None
        self._flow_domain_boundaries = None
        self._advanced_modelling = None
        self._mesh_settings_new = None
        self._is_compressible = None
        self._is_multiphase = None
        self._number_of_phases = None
        self._cavitation_model = None
        self._mesh_settings = None
        self._region_of_interest = None
        self._wind_conditions = None
        self._pedestrian_comfort_map = None
        self._additional_result_export = None
        self._enable_radiation = None
        self._enable_solar_load = None
        self._enable_humidity_model = None
        self._enable_joule_heating = None
        self._solar_calculator = None
        self._contact_handling_mode = None
        self._allow_external_flow = None
        self._external_flow_boundary_condition = None
        self._embedded_boundary_meshing = None
        self._use_local_time_stepping = None
        self._global_physics = None
        self._coils = None
        self.discriminator = 'type'

        self.type = type
        if non_linear_analysis is not None:
            self.non_linear_analysis = non_linear_analysis
        if connection_groups is not None:
            self.connection_groups = connection_groups
        if connectors is not None:
            self.connectors = connectors
        if element_technology is not None:
            self.element_technology = element_technology
        if model is not None:
            self.model = model
        if materials is not None:
            self.materials = materials
        if initial_conditions is not None:
            self.initial_conditions = initial_conditions
        if boundary_conditions is not None:
            self.boundary_conditions = boundary_conditions
        if numerics is not None:
            self.numerics = numerics
        if simulation_control is not None:
            self.simulation_control = simulation_control
        if result_control is not None:
            self.result_control = result_control
        if mesh_order is not None:
            self.mesh_order = mesh_order
        if time_dependency is not None:
            self.time_dependency = time_dependency
        if inertia_effect is not None:
            self.inertia_effect = inertia_effect
        if turbulence_model is not None:
            self.turbulence_model = turbulence_model
        if adjoint_turbulence_model is not None:
            self.adjoint_turbulence_model = adjoint_turbulence_model
        if algorithm is not None:
            self.algorithm = algorithm
        if num_of_passive_species is not None:
            self.num_of_passive_species = num_of_passive_species
        if enable_adjoint_optimization is not None:
            self.enable_adjoint_optimization = enable_adjoint_optimization
        if advanced_concepts is not None:
            self.advanced_concepts = advanced_concepts
        if bounding_box_uuid is not None:
            self.bounding_box_uuid = bounding_box_uuid
        if material is not None:
            self.material = material
        if flow_domain_boundaries is not None:
            self.flow_domain_boundaries = flow_domain_boundaries
        if advanced_modelling is not None:
            self.advanced_modelling = advanced_modelling
        if mesh_settings_new is not None:
            self.mesh_settings_new = mesh_settings_new
        if is_compressible is not None:
            self.is_compressible = is_compressible
        if is_multiphase is not None:
            self.is_multiphase = is_multiphase
        if number_of_phases is not None:
            self.number_of_phases = number_of_phases
        if cavitation_model is not None:
            self.cavitation_model = cavitation_model
        if mesh_settings is not None:
            self.mesh_settings = mesh_settings
        if region_of_interest is not None:
            self.region_of_interest = region_of_interest
        if wind_conditions is not None:
            self.wind_conditions = wind_conditions
        if pedestrian_comfort_map is not None:
            self.pedestrian_comfort_map = pedestrian_comfort_map
        if additional_result_export is not None:
            self.additional_result_export = additional_result_export
        if enable_radiation is not None:
            self.enable_radiation = enable_radiation
        if enable_solar_load is not None:
            self.enable_solar_load = enable_solar_load
        if enable_humidity_model is not None:
            self.enable_humidity_model = enable_humidity_model
        if enable_joule_heating is not None:
            self.enable_joule_heating = enable_joule_heating
        if solar_calculator is not None:
            self.solar_calculator = solar_calculator
        if contact_handling_mode is not None:
            self.contact_handling_mode = contact_handling_mode
        if allow_external_flow is not None:
            self.allow_external_flow = allow_external_flow
        if external_flow_boundary_condition is not None:
            self.external_flow_boundary_condition = external_flow_boundary_condition
        if embedded_boundary_meshing is not None:
            self.embedded_boundary_meshing = embedded_boundary_meshing
        if use_local_time_stepping is not None:
            self.use_local_time_stepping = use_local_time_stepping
        if global_physics is not None:
            self.global_physics = global_physics
        if coils is not None:
            self.coils = coils

    @property
    def type(self):
        """Gets the type of this Analysis.  # noqa: E501

        Schema name: ElectromagneticAnalysis  # noqa: E501

        :return: The type of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this Analysis.

        Schema name: ElectromagneticAnalysis  # noqa: E501

        :param type: The type of this Analysis.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501

        self._type = type

    @property
    def non_linear_analysis(self):
        """Gets the non_linear_analysis of this Analysis.  # noqa: E501

        <p>Choose if your analysis should feature any kind of <b>nonlinearity</b> like <b>physical contacts, nonlinear materials</b> as hyperelasticity or plasticity or <b>large rotations</b> and <b>large deformations, temperature dependant material properties</b> or <b>temperature dependant boundary conditions</b>. For a <b>linear analysis</b> none of those nonlinearities are available.</p>  # noqa: E501

        :return: The non_linear_analysis of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._non_linear_analysis

    @non_linear_analysis.setter
    def non_linear_analysis(self, non_linear_analysis):
        """Sets the non_linear_analysis of this Analysis.

        <p>Choose if your analysis should feature any kind of <b>nonlinearity</b> like <b>physical contacts, nonlinear materials</b> as hyperelasticity or plasticity or <b>large rotations</b> and <b>large deformations, temperature dependant material properties</b> or <b>temperature dependant boundary conditions</b>. For a <b>linear analysis</b> none of those nonlinearities are available.</p>  # noqa: E501

        :param non_linear_analysis: The non_linear_analysis of this Analysis.  # noqa: E501
        :type: bool
        """

        self._non_linear_analysis = non_linear_analysis

    @property
    def connection_groups(self):
        """Gets the connection_groups of this Analysis.  # noqa: E501


        :return: The connection_groups of this Analysis.  # noqa: E501
        :rtype: list[Contact]
        """
        return self._connection_groups

    @connection_groups.setter
    def connection_groups(self, connection_groups):
        """Sets the connection_groups of this Analysis.


        :param connection_groups: The connection_groups of this Analysis.  # noqa: E501
        :type: list[Contact]
        """

        self._connection_groups = connection_groups

    @property
    def connectors(self):
        """Gets the connectors of this Analysis.  # noqa: E501


        :return: The connectors of this Analysis.  # noqa: E501
        :rtype: list[PinConnector]
        """
        return self._connectors

    @connectors.setter
    def connectors(self, connectors):
        """Sets the connectors of this Analysis.


        :param connectors: The connectors of this Analysis.  # noqa: E501
        :type: list[PinConnector]
        """

        self._connectors = connectors

    @property
    def element_technology(self):
        """Gets the element_technology of this Analysis.  # noqa: E501


        :return: The element_technology of this Analysis.  # noqa: E501
        :rtype: SolidElementTechnology
        """
        return self._element_technology

    @element_technology.setter
    def element_technology(self, element_technology):
        """Sets the element_technology of this Analysis.


        :param element_technology: The element_technology of this Analysis.  # noqa: E501
        :type: SolidElementTechnology
        """

        self._element_technology = element_technology

    @property
    def model(self):
        """Gets the model of this Analysis.  # noqa: E501


        :return: The model of this Analysis.  # noqa: E501
        :rtype: OneOfElectromagneticAnalysisModel
        """
        return self._model

    @model.setter
    def model(self, model):
        """Sets the model of this Analysis.


        :param model: The model of this Analysis.  # noqa: E501
        :type: OneOfElectromagneticAnalysisModel
        """

        self._model = model

    @property
    def materials(self):
        """Gets the materials of this Analysis.  # noqa: E501


        :return: The materials of this Analysis.  # noqa: E501
        :rtype: list[ElectromagneticMaterial]
        """
        return self._materials

    @materials.setter
    def materials(self, materials):
        """Sets the materials of this Analysis.


        :param materials: The materials of this Analysis.  # noqa: E501
        :type: list[ElectromagneticMaterial]
        """

        self._materials = materials

    @property
    def initial_conditions(self):
        """Gets the initial_conditions of this Analysis.  # noqa: E501


        :return: The initial_conditions of this Analysis.  # noqa: E501
        :rtype: SolidInitialConditions
        """
        return self._initial_conditions

    @initial_conditions.setter
    def initial_conditions(self, initial_conditions):
        """Sets the initial_conditions of this Analysis.


        :param initial_conditions: The initial_conditions of this Analysis.  # noqa: E501
        :type: SolidInitialConditions
        """

        self._initial_conditions = initial_conditions

    @property
    def boundary_conditions(self):
        """Gets the boundary_conditions of this Analysis.  # noqa: E501


        :return: The boundary_conditions of this Analysis.  # noqa: E501
        :rtype: list[OneOfElectromagneticAnalysisBoundaryConditions]
        """
        return self._boundary_conditions

    @boundary_conditions.setter
    def boundary_conditions(self, boundary_conditions):
        """Sets the boundary_conditions of this Analysis.


        :param boundary_conditions: The boundary_conditions of this Analysis.  # noqa: E501
        :type: list[OneOfElectromagneticAnalysisBoundaryConditions]
        """

        self._boundary_conditions = boundary_conditions

    @property
    def numerics(self):
        """Gets the numerics of this Analysis.  # noqa: E501


        :return: The numerics of this Analysis.  # noqa: E501
        :rtype: ElectromagneticNumerics
        """
        return self._numerics

    @numerics.setter
    def numerics(self, numerics):
        """Sets the numerics of this Analysis.


        :param numerics: The numerics of this Analysis.  # noqa: E501
        :type: ElectromagneticNumerics
        """

        self._numerics = numerics

    @property
    def simulation_control(self):
        """Gets the simulation_control of this Analysis.  # noqa: E501


        :return: The simulation_control of this Analysis.  # noqa: E501
        :rtype: ElectromagneticSimulationControl
        """
        return self._simulation_control

    @simulation_control.setter
    def simulation_control(self, simulation_control):
        """Sets the simulation_control of this Analysis.


        :param simulation_control: The simulation_control of this Analysis.  # noqa: E501
        :type: ElectromagneticSimulationControl
        """

        self._simulation_control = simulation_control

    @property
    def result_control(self):
        """Gets the result_control of this Analysis.  # noqa: E501


        :return: The result_control of this Analysis.  # noqa: E501
        :rtype: ElectromagneticResultControl
        """
        return self._result_control

    @result_control.setter
    def result_control(self, result_control):
        """Sets the result_control of this Analysis.


        :param result_control: The result_control of this Analysis.  # noqa: E501
        :type: ElectromagneticResultControl
        """

        self._result_control = result_control

    @property
    def mesh_order(self):
        """Gets the mesh_order of this Analysis.  # noqa: E501


        :return: The mesh_order of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._mesh_order

    @mesh_order.setter
    def mesh_order(self, mesh_order):
        """Sets the mesh_order of this Analysis.


        :param mesh_order: The mesh_order of this Analysis.  # noqa: E501
        :type: str
        """
        allowed_values = ["FIRST", "SECOND", "NONE"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and mesh_order not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `mesh_order` ({0}), must be one of {1}"  # noqa: E501
                .format(mesh_order, allowed_values)
            )

        self._mesh_order = mesh_order

    @property
    def time_dependency(self):
        """Gets the time_dependency of this Analysis.  # noqa: E501


        :return: The time_dependency of this Analysis.  # noqa: E501
        :rtype: OneOfConjugateHeatTransferTimeDependency
        """
        return self._time_dependency

    @time_dependency.setter
    def time_dependency(self, time_dependency):
        """Sets the time_dependency of this Analysis.


        :param time_dependency: The time_dependency of this Analysis.  # noqa: E501
        :type: OneOfConjugateHeatTransferTimeDependency
        """

        self._time_dependency = time_dependency

    @property
    def inertia_effect(self):
        """Gets the inertia_effect of this Analysis.  # noqa: E501

        <p>Select if inertia effects should be considered in the analysis. If high loading accelerations or impacts are present then <b>dynamic</b> is the right choice for this parameter. If the dynamic effects are negligible, <b>static</b> should be selected.</p>  # noqa: E501

        :return: The inertia_effect of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._inertia_effect

    @inertia_effect.setter
    def inertia_effect(self, inertia_effect):
        """Sets the inertia_effect of this Analysis.

        <p>Select if inertia effects should be considered in the analysis. If high loading accelerations or impacts are present then <b>dynamic</b> is the right choice for this parameter. If the dynamic effects are negligible, <b>static</b> should be selected.</p>  # noqa: E501

        :param inertia_effect: The inertia_effect of this Analysis.  # noqa: E501
        :type: str
        """

        self._inertia_effect = inertia_effect

    @property
    def turbulence_model(self):
        """Gets the turbulence_model of this Analysis.  # noqa: E501

        Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/#standard-k-epsilon-model' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/#realizable-k-epsilon-model' target='_blank'>Realizable k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>  # noqa: E501

        :return: The turbulence_model of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._turbulence_model

    @turbulence_model.setter
    def turbulence_model(self, turbulence_model):
        """Sets the turbulence_model of this Analysis.

        Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/#standard-k-epsilon-model' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/#realizable-k-epsilon-model' target='_blank'>Realizable k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>  # noqa: E501

        :param turbulence_model: The turbulence_model of this Analysis.  # noqa: E501
        :type: str
        """
        allowed_values = ["SMAGORINSKY", "NONE", "KEPSILON", "KOMEGASST"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and turbulence_model not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `turbulence_model` ({0}), must be one of {1}"  # noqa: E501
                .format(turbulence_model, allowed_values)
            )

        self._turbulence_model = turbulence_model

    @property
    def adjoint_turbulence_model(self):
        """Gets the adjoint_turbulence_model of this Analysis.  # noqa: E501


        :return: The adjoint_turbulence_model of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._adjoint_turbulence_model

    @adjoint_turbulence_model.setter
    def adjoint_turbulence_model(self, adjoint_turbulence_model):
        """Sets the adjoint_turbulence_model of this Analysis.


        :param adjoint_turbulence_model: The adjoint_turbulence_model of this Analysis.  # noqa: E501
        :type: str
        """
        allowed_values = ["ADJOINT_NONE", "ADJOINT_KOMEGASST"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and adjoint_turbulence_model not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `adjoint_turbulence_model` ({0}), must be one of {1}"  # noqa: E501
                .format(adjoint_turbulence_model, allowed_values)
            )

        self._adjoint_turbulence_model = adjoint_turbulence_model

    @property
    def algorithm(self):
        """Gets the algorithm of this Analysis.  # noqa: E501


        :return: The algorithm of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._algorithm

    @algorithm.setter
    def algorithm(self, algorithm):
        """Sets the algorithm of this Analysis.


        :param algorithm: The algorithm of this Analysis.  # noqa: E501
        :type: str
        """

        self._algorithm = algorithm

    @property
    def num_of_passive_species(self):
        """Gets the num_of_passive_species of this Analysis.  # noqa: E501

        Select the number of passive species involved in the simulation. Passive species allow you to simulate the transport of a scalar quantity within a fluid flow without affecting it. <a href='https://www.simscale.com/docs/simulation-setup/global-settings/#passive-species' target='_blank'>Learn more</a>.  # noqa: E501

        :return: The num_of_passive_species of this Analysis.  # noqa: E501
        :rtype: int
        """
        return self._num_of_passive_species

    @num_of_passive_species.setter
    def num_of_passive_species(self, num_of_passive_species):
        """Sets the num_of_passive_species of this Analysis.

        Select the number of passive species involved in the simulation. Passive species allow you to simulate the transport of a scalar quantity within a fluid flow without affecting it. <a href='https://www.simscale.com/docs/simulation-setup/global-settings/#passive-species' target='_blank'>Learn more</a>.  # noqa: E501

        :param num_of_passive_species: The num_of_passive_species of this Analysis.  # noqa: E501
        :type: int
        """
        allowed_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and num_of_passive_species not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `num_of_passive_species` ({0}), must be one of {1}"  # noqa: E501
                .format(num_of_passive_species, allowed_values)
            )

        self._num_of_passive_species = num_of_passive_species

    @property
    def enable_adjoint_optimization(self):
        """Gets the enable_adjoint_optimization of this Analysis.  # noqa: E501


        :return: The enable_adjoint_optimization of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._enable_adjoint_optimization

    @enable_adjoint_optimization.setter
    def enable_adjoint_optimization(self, enable_adjoint_optimization):
        """Sets the enable_adjoint_optimization of this Analysis.


        :param enable_adjoint_optimization: The enable_adjoint_optimization of this Analysis.  # noqa: E501
        :type: bool
        """

        self._enable_adjoint_optimization = enable_adjoint_optimization

    @property
    def advanced_concepts(self):
        """Gets the advanced_concepts of this Analysis.  # noqa: E501


        :return: The advanced_concepts of this Analysis.  # noqa: E501
        :rtype: AdvancedConcepts
        """
        return self._advanced_concepts

    @advanced_concepts.setter
    def advanced_concepts(self, advanced_concepts):
        """Sets the advanced_concepts of this Analysis.


        :param advanced_concepts: The advanced_concepts of this Analysis.  # noqa: E501
        :type: AdvancedConcepts
        """

        self._advanced_concepts = advanced_concepts

    @property
    def bounding_box_uuid(self):
        """Gets the bounding_box_uuid of this Analysis.  # noqa: E501


        :return: The bounding_box_uuid of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._bounding_box_uuid

    @bounding_box_uuid.setter
    def bounding_box_uuid(self, bounding_box_uuid):
        """Sets the bounding_box_uuid of this Analysis.


        :param bounding_box_uuid: The bounding_box_uuid of this Analysis.  # noqa: E501
        :type: str
        """

        self._bounding_box_uuid = bounding_box_uuid

    @property
    def material(self):
        """Gets the material of this Analysis.  # noqa: E501


        :return: The material of this Analysis.  # noqa: E501
        :rtype: IncompressibleMaterial
        """
        return self._material

    @material.setter
    def material(self, material):
        """Sets the material of this Analysis.


        :param material: The material of this Analysis.  # noqa: E501
        :type: IncompressibleMaterial
        """

        self._material = material

    @property
    def flow_domain_boundaries(self):
        """Gets the flow_domain_boundaries of this Analysis.  # noqa: E501


        :return: The flow_domain_boundaries of this Analysis.  # noqa: E501
        :rtype: FlowDomainBoundaries
        """
        return self._flow_domain_boundaries

    @flow_domain_boundaries.setter
    def flow_domain_boundaries(self, flow_domain_boundaries):
        """Sets the flow_domain_boundaries of this Analysis.


        :param flow_domain_boundaries: The flow_domain_boundaries of this Analysis.  # noqa: E501
        :type: FlowDomainBoundaries
        """

        self._flow_domain_boundaries = flow_domain_boundaries

    @property
    def advanced_modelling(self):
        """Gets the advanced_modelling of this Analysis.  # noqa: E501


        :return: The advanced_modelling of this Analysis.  # noqa: E501
        :rtype: AdvancedModelling
        """
        return self._advanced_modelling

    @advanced_modelling.setter
    def advanced_modelling(self, advanced_modelling):
        """Sets the advanced_modelling of this Analysis.


        :param advanced_modelling: The advanced_modelling of this Analysis.  # noqa: E501
        :type: AdvancedModelling
        """

        self._advanced_modelling = advanced_modelling

    @property
    def mesh_settings_new(self):
        """Gets the mesh_settings_new of this Analysis.  # noqa: E501


        :return: The mesh_settings_new of this Analysis.  # noqa: E501
        :rtype: OneOfIncompressiblePacefishMeshSettingsNew
        """
        return self._mesh_settings_new

    @mesh_settings_new.setter
    def mesh_settings_new(self, mesh_settings_new):
        """Sets the mesh_settings_new of this Analysis.


        :param mesh_settings_new: The mesh_settings_new of this Analysis.  # noqa: E501
        :type: OneOfIncompressiblePacefishMeshSettingsNew
        """

        self._mesh_settings_new = mesh_settings_new

    @property
    def is_compressible(self):
        """Gets the is_compressible of this Analysis.  # noqa: E501

        <ul><li>Toggle off <em>Compressible</em> for small temperature variations within the domain, for example, in natural convection simulations (Boussinesq approximation). Use Gauge pressure (0 Pa). </li><li>Toggle on <em>Compressible</em> to calculate resulting density variations within the domain based on pressure and temperature. Use Absolute pressure (for example, 101325 Pa at sea level)</li></ul>  # noqa: E501

        :return: The is_compressible of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._is_compressible

    @is_compressible.setter
    def is_compressible(self, is_compressible):
        """Sets the is_compressible of this Analysis.

        <ul><li>Toggle off <em>Compressible</em> for small temperature variations within the domain, for example, in natural convection simulations (Boussinesq approximation). Use Gauge pressure (0 Pa). </li><li>Toggle on <em>Compressible</em> to calculate resulting density variations within the domain based on pressure and temperature. Use Absolute pressure (for example, 101325 Pa at sea level)</li></ul>  # noqa: E501

        :param is_compressible: The is_compressible of this Analysis.  # noqa: E501
        :type: bool
        """

        self._is_compressible = is_compressible

    @property
    def is_multiphase(self):
        """Gets the is_multiphase of this Analysis.  # noqa: E501


        :return: The is_multiphase of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._is_multiphase

    @is_multiphase.setter
    def is_multiphase(self, is_multiphase):
        """Sets the is_multiphase of this Analysis.


        :param is_multiphase: The is_multiphase of this Analysis.  # noqa: E501
        :type: bool
        """

        self._is_multiphase = is_multiphase

    @property
    def number_of_phases(self):
        """Gets the number_of_phases of this Analysis.  # noqa: E501


        :return: The number_of_phases of this Analysis.  # noqa: E501
        :rtype: int
        """
        return self._number_of_phases

    @number_of_phases.setter
    def number_of_phases(self, number_of_phases):
        """Sets the number_of_phases of this Analysis.


        :param number_of_phases: The number_of_phases of this Analysis.  # noqa: E501
        :type: int
        """
        if (self.local_vars_configuration.client_side_validation and
                number_of_phases is not None and number_of_phases > 2):  # noqa: E501
            raise ValueError("Invalid value for `number_of_phases`, must be a value less than or equal to `2`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                number_of_phases is not None and number_of_phases < 2):  # noqa: E501
            raise ValueError("Invalid value for `number_of_phases`, must be a value greater than or equal to `2`")  # noqa: E501

        self._number_of_phases = number_of_phases

    @property
    def cavitation_model(self):
        """Gets the cavitation_model of this Analysis.  # noqa: E501


        :return: The cavitation_model of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._cavitation_model

    @cavitation_model.setter
    def cavitation_model(self, cavitation_model):
        """Sets the cavitation_model of this Analysis.


        :param cavitation_model: The cavitation_model of this Analysis.  # noqa: E501
        :type: str
        """
        allowed_values = ["CONSTANT_GAS_MASS_FRACTION", "NONE"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and cavitation_model not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `cavitation_model` ({0}), must be one of {1}"  # noqa: E501
                .format(cavitation_model, allowed_values)
            )

        self._cavitation_model = cavitation_model

    @property
    def mesh_settings(self):
        """Gets the mesh_settings of this Analysis.  # noqa: E501


        :return: The mesh_settings of this Analysis.  # noqa: E501
        :rtype: WindComfortMesh
        """
        return self._mesh_settings

    @mesh_settings.setter
    def mesh_settings(self, mesh_settings):
        """Sets the mesh_settings of this Analysis.


        :param mesh_settings: The mesh_settings of this Analysis.  # noqa: E501
        :type: WindComfortMesh
        """

        self._mesh_settings = mesh_settings

    @property
    def region_of_interest(self):
        """Gets the region_of_interest of this Analysis.  # noqa: E501


        :return: The region_of_interest of this Analysis.  # noqa: E501
        :rtype: RegionOfInterest
        """
        return self._region_of_interest

    @region_of_interest.setter
    def region_of_interest(self, region_of_interest):
        """Sets the region_of_interest of this Analysis.


        :param region_of_interest: The region_of_interest of this Analysis.  # noqa: E501
        :type: RegionOfInterest
        """

        self._region_of_interest = region_of_interest

    @property
    def wind_conditions(self):
        """Gets the wind_conditions of this Analysis.  # noqa: E501


        :return: The wind_conditions of this Analysis.  # noqa: E501
        :rtype: WindConditions
        """
        return self._wind_conditions

    @wind_conditions.setter
    def wind_conditions(self, wind_conditions):
        """Sets the wind_conditions of this Analysis.


        :param wind_conditions: The wind_conditions of this Analysis.  # noqa: E501
        :type: WindConditions
        """

        self._wind_conditions = wind_conditions

    @property
    def pedestrian_comfort_map(self):
        """Gets the pedestrian_comfort_map of this Analysis.  # noqa: E501


        :return: The pedestrian_comfort_map of this Analysis.  # noqa: E501
        :rtype: list[PedestrianComfortSurface]
        """
        return self._pedestrian_comfort_map

    @pedestrian_comfort_map.setter
    def pedestrian_comfort_map(self, pedestrian_comfort_map):
        """Sets the pedestrian_comfort_map of this Analysis.


        :param pedestrian_comfort_map: The pedestrian_comfort_map of this Analysis.  # noqa: E501
        :type: list[PedestrianComfortSurface]
        """

        self._pedestrian_comfort_map = pedestrian_comfort_map

    @property
    def additional_result_export(self):
        """Gets the additional_result_export of this Analysis.  # noqa: E501


        :return: The additional_result_export of this Analysis.  # noqa: E501
        :rtype: FluidResultControls
        """
        return self._additional_result_export

    @additional_result_export.setter
    def additional_result_export(self, additional_result_export):
        """Sets the additional_result_export of this Analysis.


        :param additional_result_export: The additional_result_export of this Analysis.  # noqa: E501
        :type: FluidResultControls
        """

        self._additional_result_export = additional_result_export

    @property
    def enable_radiation(self):
        """Gets the enable_radiation of this Analysis.  # noqa: E501

        Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperature differences in the simulation domain are large. <a href='https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/' target='_blank'>Learn more</a>.  # noqa: E501

        :return: The enable_radiation of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._enable_radiation

    @enable_radiation.setter
    def enable_radiation(self, enable_radiation):
        """Sets the enable_radiation of this Analysis.

        Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperature differences in the simulation domain are large. <a href='https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/' target='_blank'>Learn more</a>.  # noqa: E501

        :param enable_radiation: The enable_radiation of this Analysis.  # noqa: E501
        :type: bool
        """

        self._enable_radiation = enable_radiation

    @property
    def enable_solar_load(self):
        """Gets the enable_solar_load of this Analysis.  # noqa: E501

        Enables the <b>Solar load</b> model in the simulation. Diffuse and/or directional solar load contributions are specified in the <b>Solar calculator</b>. The solar load terms will heat the external faces of the simulation domain. Moreover, if transparent and/or semi-transparent surfaces are present, internal surfaces of the domain might also be heated. The solar model can be used with or without a radiation model, and it cannot be used if the simulation contains solids. <a href='https://www.simscale.com/docs/analysis-types/conjugate-heat-transfer-analysis/solar-load/' target='_blank'>Learn more</a>.  # noqa: E501

        :return: The enable_solar_load of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._enable_solar_load

    @enable_solar_load.setter
    def enable_solar_load(self, enable_solar_load):
        """Sets the enable_solar_load of this Analysis.

        Enables the <b>Solar load</b> model in the simulation. Diffuse and/or directional solar load contributions are specified in the <b>Solar calculator</b>. The solar load terms will heat the external faces of the simulation domain. Moreover, if transparent and/or semi-transparent surfaces are present, internal surfaces of the domain might also be heated. The solar model can be used with or without a radiation model, and it cannot be used if the simulation contains solids. <a href='https://www.simscale.com/docs/analysis-types/conjugate-heat-transfer-analysis/solar-load/' target='_blank'>Learn more</a>.  # noqa: E501

        :param enable_solar_load: The enable_solar_load of this Analysis.  # noqa: E501
        :type: bool
        """

        self._enable_solar_load = enable_solar_load

    @property
    def enable_humidity_model(self):
        """Gets the enable_humidity_model of this Analysis.  # noqa: E501

        <b>Humidity model</b> to simulate wet air. First turn on the <em>compressible</em> toggle to enable it. The simulation will take the effect of humid air on the flow field into account. Dry air is heavier than wet air and hence sinks. The model does not account for condensation and evaporation and is not applicable in cases where this is of concern, for example dehumidifiers. It is suitable for HVAC analysis and for temperature ranges of <b>0° to 100°C</b>. </li></ul></p><a href= https://www.simscale.com/docs/simulation-setup/global-settings/humidity-modeling/' target='_blank'>Learn more</a>.  # noqa: E501

        :return: The enable_humidity_model of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._enable_humidity_model

    @enable_humidity_model.setter
    def enable_humidity_model(self, enable_humidity_model):
        """Sets the enable_humidity_model of this Analysis.

        <b>Humidity model</b> to simulate wet air. First turn on the <em>compressible</em> toggle to enable it. The simulation will take the effect of humid air on the flow field into account. Dry air is heavier than wet air and hence sinks. The model does not account for condensation and evaporation and is not applicable in cases where this is of concern, for example dehumidifiers. It is suitable for HVAC analysis and for temperature ranges of <b>0° to 100°C</b>. </li></ul></p><a href= https://www.simscale.com/docs/simulation-setup/global-settings/humidity-modeling/' target='_blank'>Learn more</a>.  # noqa: E501

        :param enable_humidity_model: The enable_humidity_model of this Analysis.  # noqa: E501
        :type: bool
        """

        self._enable_humidity_model = enable_humidity_model

    @property
    def enable_joule_heating(self):
        """Gets the enable_joule_heating of this Analysis.  # noqa: E501

        Enabling <b>Joule heating</b> gives you the possibility to solve a coupled electric conduction and conjugate heat transfer problem in a single simulation.  # noqa: E501

        :return: The enable_joule_heating of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._enable_joule_heating

    @enable_joule_heating.setter
    def enable_joule_heating(self, enable_joule_heating):
        """Sets the enable_joule_heating of this Analysis.

        Enabling <b>Joule heating</b> gives you the possibility to solve a coupled electric conduction and conjugate heat transfer problem in a single simulation.  # noqa: E501

        :param enable_joule_heating: The enable_joule_heating of this Analysis.  # noqa: E501
        :type: bool
        """

        self._enable_joule_heating = enable_joule_heating

    @property
    def solar_calculator(self):
        """Gets the solar_calculator of this Analysis.  # noqa: E501


        :return: The solar_calculator of this Analysis.  # noqa: E501
        :rtype: SolarCalculator
        """
        return self._solar_calculator

    @solar_calculator.setter
    def solar_calculator(self, solar_calculator):
        """Sets the solar_calculator of this Analysis.


        :param solar_calculator: The solar_calculator of this Analysis.  # noqa: E501
        :type: SolarCalculator
        """

        self._solar_calculator = solar_calculator

    @property
    def contact_handling_mode(self):
        """Gets the contact_handling_mode of this Analysis.  # noqa: E501


        :return: The contact_handling_mode of this Analysis.  # noqa: E501
        :rtype: str
        """
        return self._contact_handling_mode

    @contact_handling_mode.setter
    def contact_handling_mode(self, contact_handling_mode):
        """Sets the contact_handling_mode of this Analysis.


        :param contact_handling_mode: The contact_handling_mode of this Analysis.  # noqa: E501
        :type: str
        """
        allowed_values = ["MANUAL", "AUTO"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and contact_handling_mode not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `contact_handling_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(contact_handling_mode, allowed_values)
            )

        self._contact_handling_mode = contact_handling_mode

    @property
    def allow_external_flow(self):
        """Gets the allow_external_flow of this Analysis.  # noqa: E501

        This toggle allows you to create an additional external fluid domain via a Cartesian box. Enable this toggle if you want to simulate for example natural convection around your system and the external flow domain is not represented in your CAD model as a solid body.  # noqa: E501

        :return: The allow_external_flow of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._allow_external_flow

    @allow_external_flow.setter
    def allow_external_flow(self, allow_external_flow):
        """Sets the allow_external_flow of this Analysis.

        This toggle allows you to create an additional external fluid domain via a Cartesian box. Enable this toggle if you want to simulate for example natural convection around your system and the external flow domain is not represented in your CAD model as a solid body.  # noqa: E501

        :param allow_external_flow: The allow_external_flow of this Analysis.  # noqa: E501
        :type: bool
        """

        self._allow_external_flow = allow_external_flow

    @property
    def external_flow_boundary_condition(self):
        """Gets the external_flow_boundary_condition of this Analysis.  # noqa: E501


        :return: The external_flow_boundary_condition of this Analysis.  # noqa: E501
        :rtype: OneOfEmbeddedBoundaryExternalFlowBoundaryCondition
        """
        return self._external_flow_boundary_condition

    @external_flow_boundary_condition.setter
    def external_flow_boundary_condition(self, external_flow_boundary_condition):
        """Sets the external_flow_boundary_condition of this Analysis.


        :param external_flow_boundary_condition: The external_flow_boundary_condition of this Analysis.  # noqa: E501
        :type: OneOfEmbeddedBoundaryExternalFlowBoundaryCondition
        """

        self._external_flow_boundary_condition = external_flow_boundary_condition

    @property
    def embedded_boundary_meshing(self):
        """Gets the embedded_boundary_meshing of this Analysis.  # noqa: E501


        :return: The embedded_boundary_meshing of this Analysis.  # noqa: E501
        :rtype: EmbeddedBoundaryMeshing
        """
        return self._embedded_boundary_meshing

    @embedded_boundary_meshing.setter
    def embedded_boundary_meshing(self, embedded_boundary_meshing):
        """Sets the embedded_boundary_meshing of this Analysis.


        :param embedded_boundary_meshing: The embedded_boundary_meshing of this Analysis.  # noqa: E501
        :type: EmbeddedBoundaryMeshing
        """

        self._embedded_boundary_meshing = embedded_boundary_meshing

    @property
    def use_local_time_stepping(self):
        """Gets the use_local_time_stepping of this Analysis.  # noqa: E501

        With the <i>Local time stepping</i> option enabled, it’s possible to accelerate the simulation towards a steady-state. As a result, faster computing times and smaller result data size. Commonly used in ship hull resistance analysis.  # noqa: E501

        :return: The use_local_time_stepping of this Analysis.  # noqa: E501
        :rtype: bool
        """
        return self._use_local_time_stepping

    @use_local_time_stepping.setter
    def use_local_time_stepping(self, use_local_time_stepping):
        """Sets the use_local_time_stepping of this Analysis.

        With the <i>Local time stepping</i> option enabled, it’s possible to accelerate the simulation towards a steady-state. As a result, faster computing times and smaller result data size. Commonly used in ship hull resistance analysis.  # noqa: E501

        :param use_local_time_stepping: The use_local_time_stepping of this Analysis.  # noqa: E501
        :type: bool
        """

        self._use_local_time_stepping = use_local_time_stepping

    @property
    def global_physics(self):
        """Gets the global_physics of this Analysis.  # noqa: E501


        :return: The global_physics of this Analysis.  # noqa: E501
        :rtype: SolidGlobalPhysics
        """
        return self._global_physics

    @global_physics.setter
    def global_physics(self, global_physics):
        """Sets the global_physics of this Analysis.


        :param global_physics: The global_physics of this Analysis.  # noqa: E501
        :type: SolidGlobalPhysics
        """

        self._global_physics = global_physics

    @property
    def coils(self):
        """Gets the coils of this Analysis.  # noqa: E501


        :return: The coils of this Analysis.  # noqa: E501
        :rtype: list[Coil]
        """
        return self._coils

    @coils.setter
    def coils(self, coils):
        """Sets the coils of this Analysis.


        :param coils: The coils of this Analysis.  # noqa: E501
        :type: list[Coil]
        """

        self._coils = coils

    def get_real_child_model(self, data):
        """Returns the real base class specified by the discriminator"""
        discriminator_key = self.attribute_map[self.discriminator]
        discriminator_value = data[discriminator_key]
        return self.discriminator_value_class_map.get(discriminator_value)

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Analysis):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Analysis):
            return True

        return self.to_dict() != other.to_dict()
