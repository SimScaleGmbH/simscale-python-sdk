# coding: utf-8

"""
    SimScale API

    The version of the OpenAPI document: 0.0.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from simscale_sdk.configuration import Configuration


class CastellatedMeshControls(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'max_local_cells': 'int',
        'max_global_cells': 'int',
        'min_refinement_cells': 'int',
        'max_load_unbalance': 'float',
        'cells_between_levels': 'int',
        'resolve_feature_angle': 'float',
        'allow_free_standing_zone_faces': 'bool'
    }

    attribute_map = {
        'max_local_cells': 'maxLocalCells',
        'max_global_cells': 'maxGlobalCells',
        'min_refinement_cells': 'minRefinementCells',
        'max_load_unbalance': 'maxLoadUnbalance',
        'cells_between_levels': 'cellsBetweenLevels',
        'resolve_feature_angle': 'resolveFeatureAngle',
        'allow_free_standing_zone_faces': 'allowFreeStandingZoneFaces'
    }

    def __init__(self, max_local_cells=None, max_global_cells=None, min_refinement_cells=None, max_load_unbalance=None, cells_between_levels=None, resolve_feature_angle=None, allow_free_standing_zone_faces=None, local_vars_configuration=None):  # noqa: E501
        """CastellatedMeshControls - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._max_local_cells = None
        self._max_global_cells = None
        self._min_refinement_cells = None
        self._max_load_unbalance = None
        self._cells_between_levels = None
        self._resolve_feature_angle = None
        self._allow_free_standing_zone_faces = None
        self.discriminator = None

        if max_local_cells is not None:
            self.max_local_cells = max_local_cells
        if max_global_cells is not None:
            self.max_global_cells = max_global_cells
        if min_refinement_cells is not None:
            self.min_refinement_cells = min_refinement_cells
        if max_load_unbalance is not None:
            self.max_load_unbalance = max_load_unbalance
        if cells_between_levels is not None:
            self.cells_between_levels = cells_between_levels
        if resolve_feature_angle is not None:
            self.resolve_feature_angle = resolve_feature_angle
        if allow_free_standing_zone_faces is not None:
            self.allow_free_standing_zone_faces = allow_free_standing_zone_faces

    @property
    def max_local_cells(self):
        """Gets the max_local_cells of this CastellatedMeshControls.  # noqa: E501

        <p>Define the maximal number of cells per processor during refinement</p>  # noqa: E501

        :return: The max_local_cells of this CastellatedMeshControls.  # noqa: E501
        :rtype: int
        """
        return self._max_local_cells

    @max_local_cells.setter
    def max_local_cells(self, max_local_cells):
        """Sets the max_local_cells of this CastellatedMeshControls.

        <p>Define the maximal number of cells per processor during refinement</p>  # noqa: E501

        :param max_local_cells: The max_local_cells of this CastellatedMeshControls.  # noqa: E501
        :type: int
        """
        if (self.local_vars_configuration.client_side_validation and
                max_local_cells is not None and max_local_cells > 2000000000):  # noqa: E501
            raise ValueError("Invalid value for `max_local_cells`, must be a value less than or equal to `2000000000`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                max_local_cells is not None and max_local_cells < 0):  # noqa: E501
            raise ValueError("Invalid value for `max_local_cells`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_local_cells = max_local_cells

    @property
    def max_global_cells(self):
        """Gets the max_global_cells of this CastellatedMeshControls.  # noqa: E501

        <p>Define the maximum possible number of cells summed upon all processors. Note that this is before the castellation step (see documentation, so the actual number of cells after castellation might be considerably less.</p>  # noqa: E501

        :return: The max_global_cells of this CastellatedMeshControls.  # noqa: E501
        :rtype: int
        """
        return self._max_global_cells

    @max_global_cells.setter
    def max_global_cells(self, max_global_cells):
        """Sets the max_global_cells of this CastellatedMeshControls.

        <p>Define the maximum possible number of cells summed upon all processors. Note that this is before the castellation step (see documentation, so the actual number of cells after castellation might be considerably less.</p>  # noqa: E501

        :param max_global_cells: The max_global_cells of this CastellatedMeshControls.  # noqa: E501
        :type: int
        """
        if (self.local_vars_configuration.client_side_validation and
                max_global_cells is not None and max_global_cells > 2000000000):  # noqa: E501
            raise ValueError("Invalid value for `max_global_cells`, must be a value less than or equal to `2000000000`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                max_global_cells is not None and max_global_cells < 0):  # noqa: E501
            raise ValueError("Invalid value for `max_global_cells`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_global_cells = max_global_cells

    @property
    def min_refinement_cells(self):
        """Gets the min_refinement_cells of this CastellatedMeshControls.  # noqa: E501

        <p>If in a refinement iteration the number of cells selected for refinement is under this value, the refinement stops. Provide a small value to ensure that all surfaces are refined to the proper level.</p>  # noqa: E501

        :return: The min_refinement_cells of this CastellatedMeshControls.  # noqa: E501
        :rtype: int
        """
        return self._min_refinement_cells

    @min_refinement_cells.setter
    def min_refinement_cells(self, min_refinement_cells):
        """Sets the min_refinement_cells of this CastellatedMeshControls.

        <p>If in a refinement iteration the number of cells selected for refinement is under this value, the refinement stops. Provide a small value to ensure that all surfaces are refined to the proper level.</p>  # noqa: E501

        :param min_refinement_cells: The min_refinement_cells of this CastellatedMeshControls.  # noqa: E501
        :type: int
        """
        if (self.local_vars_configuration.client_side_validation and
                min_refinement_cells is not None and min_refinement_cells < 1):  # noqa: E501
            raise ValueError("Invalid value for `min_refinement_cells`, must be a value greater than or equal to `1`")  # noqa: E501

        self._min_refinement_cells = min_refinement_cells

    @property
    def max_load_unbalance(self):
        """Gets the max_load_unbalance of this CastellatedMeshControls.  # noqa: E501

        <p>Define a fraction indicating the maximum allowable load imbalance between processors working on this job. A value of 0 will force rebalancing for even a slight imbalance.</p>  # noqa: E501

        :return: The max_load_unbalance of this CastellatedMeshControls.  # noqa: E501
        :rtype: float
        """
        return self._max_load_unbalance

    @max_load_unbalance.setter
    def max_load_unbalance(self, max_load_unbalance):
        """Sets the max_load_unbalance of this CastellatedMeshControls.

        <p>Define a fraction indicating the maximum allowable load imbalance between processors working on this job. A value of 0 will force rebalancing for even a slight imbalance.</p>  # noqa: E501

        :param max_load_unbalance: The max_load_unbalance of this CastellatedMeshControls.  # noqa: E501
        :type: float
        """
        if (self.local_vars_configuration.client_side_validation and
                max_load_unbalance is not None and max_load_unbalance > 1):  # noqa: E501
            raise ValueError("Invalid value for `max_load_unbalance`, must be a value less than or equal to `1`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                max_load_unbalance is not None and max_load_unbalance < 0):  # noqa: E501
            raise ValueError("Invalid value for `max_load_unbalance`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_load_unbalance = max_load_unbalance

    @property
    def cells_between_levels(self):
        """Gets the cells_between_levels of this CastellatedMeshControls.  # noqa: E501

        <p>This parameter specifies the number of layers of cells between different levels of refinement (see documentation).</p>  # noqa: E501

        :return: The cells_between_levels of this CastellatedMeshControls.  # noqa: E501
        :rtype: int
        """
        return self._cells_between_levels

    @cells_between_levels.setter
    def cells_between_levels(self, cells_between_levels):
        """Sets the cells_between_levels of this CastellatedMeshControls.

        <p>This parameter specifies the number of layers of cells between different levels of refinement (see documentation).</p>  # noqa: E501

        :param cells_between_levels: The cells_between_levels of this CastellatedMeshControls.  # noqa: E501
        :type: int
        """
        if (self.local_vars_configuration.client_side_validation and
                cells_between_levels is not None and cells_between_levels < 0):  # noqa: E501
            raise ValueError("Invalid value for `cells_between_levels`, must be a value greater than or equal to `0`")  # noqa: E501

        self._cells_between_levels = cells_between_levels

    @property
    def resolve_feature_angle(self):
        """Gets the resolve_feature_angle of this CastellatedMeshControls.  # noqa: E501

        <p>Cells that face multiple intersections with an intersection angle greater than this angle will be refined to the max level. Use this parameter to resolve sharp features to the maximum level of surface refinement specified (see documentation).</p>  # noqa: E501

        :return: The resolve_feature_angle of this CastellatedMeshControls.  # noqa: E501
        :rtype: float
        """
        return self._resolve_feature_angle

    @resolve_feature_angle.setter
    def resolve_feature_angle(self, resolve_feature_angle):
        """Sets the resolve_feature_angle of this CastellatedMeshControls.

        <p>Cells that face multiple intersections with an intersection angle greater than this angle will be refined to the max level. Use this parameter to resolve sharp features to the maximum level of surface refinement specified (see documentation).</p>  # noqa: E501

        :param resolve_feature_angle: The resolve_feature_angle of this CastellatedMeshControls.  # noqa: E501
        :type: float
        """
        if (self.local_vars_configuration.client_side_validation and
                resolve_feature_angle is not None and resolve_feature_angle > 180):  # noqa: E501
            raise ValueError("Invalid value for `resolve_feature_angle`, must be a value less than or equal to `180`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                resolve_feature_angle is not None and resolve_feature_angle < 0):  # noqa: E501
            raise ValueError("Invalid value for `resolve_feature_angle`, must be a value greater than or equal to `0`")  # noqa: E501

        self._resolve_feature_angle = resolve_feature_angle

    @property
    def allow_free_standing_zone_faces(self):
        """Gets the allow_free_standing_zone_faces of this CastellatedMeshControls.  # noqa: E501

        <p>Decide whether you want to allow zone faces that share the same owner and neighbour cell zone. Allowing this can lead to problem when zone faces are snapped to features. This parameter is ignored when no faceZones are present.</p>  # noqa: E501

        :return: The allow_free_standing_zone_faces of this CastellatedMeshControls.  # noqa: E501
        :rtype: bool
        """
        return self._allow_free_standing_zone_faces

    @allow_free_standing_zone_faces.setter
    def allow_free_standing_zone_faces(self, allow_free_standing_zone_faces):
        """Sets the allow_free_standing_zone_faces of this CastellatedMeshControls.

        <p>Decide whether you want to allow zone faces that share the same owner and neighbour cell zone. Allowing this can lead to problem when zone faces are snapped to features. This parameter is ignored when no faceZones are present.</p>  # noqa: E501

        :param allow_free_standing_zone_faces: The allow_free_standing_zone_faces of this CastellatedMeshControls.  # noqa: E501
        :type: bool
        """

        self._allow_free_standing_zone_faces = allow_free_standing_zone_faces

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, CastellatedMeshControls):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, CastellatedMeshControls):
            return True

        return self.to_dict() != other.to_dict()
