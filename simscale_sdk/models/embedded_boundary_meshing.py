# coding: utf-8

"""
    SimScale API

    The version of the OpenAPI document: 0.0.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from simscale_sdk.configuration import Configuration


class EmbeddedBoundaryMeshing(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'sizing': 'OneOfEmbeddedBoundaryMeshingSizing',
        'number_of_buffer_cells': 'float',
        'refinements': 'list[OneOfEmbeddedBoundaryMeshingRefinements]'
    }

    attribute_map = {
        'sizing': 'sizing',
        'number_of_buffer_cells': 'numberOfBufferCells',
        'refinements': 'refinements'
    }

    def __init__(self, sizing=None, number_of_buffer_cells=None, refinements=None, local_vars_configuration=None):  # noqa: E501
        """EmbeddedBoundaryMeshing - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._sizing = None
        self._number_of_buffer_cells = None
        self._refinements = None
        self.discriminator = None

        if sizing is not None:
            self.sizing = sizing
        if number_of_buffer_cells is not None:
            self.number_of_buffer_cells = number_of_buffer_cells
        if refinements is not None:
            self.refinements = refinements

    @property
    def sizing(self):
        """Gets the sizing of this EmbeddedBoundaryMeshing.  # noqa: E501


        :return: The sizing of this EmbeddedBoundaryMeshing.  # noqa: E501
        :rtype: OneOfEmbeddedBoundaryMeshingSizing
        """
        return self._sizing

    @sizing.setter
    def sizing(self, sizing):
        """Sets the sizing of this EmbeddedBoundaryMeshing.


        :param sizing: The sizing of this EmbeddedBoundaryMeshing.  # noqa: E501
        :type: OneOfEmbeddedBoundaryMeshingSizing
        """

        self._sizing = sizing

    @property
    def number_of_buffer_cells(self):
        """Gets the number_of_buffer_cells of this EmbeddedBoundaryMeshing.  # noqa: E501

        Target number of cells for every cell size level. Higher number of buffer cells ensure smoother cell size transitions, which results in better accuracy but bigger computation costs. On the other hand, lower number of buffer cells will result in smaller computation costs but worse accuracy. <img src=\"/spec/resources/help/imgs/buffer_cells.png\" class=\"helpPopupImage\"/>  # noqa: E501

        :return: The number_of_buffer_cells of this EmbeddedBoundaryMeshing.  # noqa: E501
        :rtype: float
        """
        return self._number_of_buffer_cells

    @number_of_buffer_cells.setter
    def number_of_buffer_cells(self, number_of_buffer_cells):
        """Sets the number_of_buffer_cells of this EmbeddedBoundaryMeshing.

        Target number of cells for every cell size level. Higher number of buffer cells ensure smoother cell size transitions, which results in better accuracy but bigger computation costs. On the other hand, lower number of buffer cells will result in smaller computation costs but worse accuracy. <img src=\"/spec/resources/help/imgs/buffer_cells.png\" class=\"helpPopupImage\"/>  # noqa: E501

        :param number_of_buffer_cells: The number_of_buffer_cells of this EmbeddedBoundaryMeshing.  # noqa: E501
        :type: float
        """
        if (self.local_vars_configuration.client_side_validation and
                number_of_buffer_cells is not None and number_of_buffer_cells > 10):  # noqa: E501
            raise ValueError("Invalid value for `number_of_buffer_cells`, must be a value less than or equal to `10`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                number_of_buffer_cells is not None and number_of_buffer_cells < 0):  # noqa: E501
            raise ValueError("Invalid value for `number_of_buffer_cells`, must be a value greater than or equal to `0`")  # noqa: E501

        self._number_of_buffer_cells = number_of_buffer_cells

    @property
    def refinements(self):
        """Gets the refinements of this EmbeddedBoundaryMeshing.  # noqa: E501


        :return: The refinements of this EmbeddedBoundaryMeshing.  # noqa: E501
        :rtype: list[OneOfEmbeddedBoundaryMeshingRefinements]
        """
        return self._refinements

    @refinements.setter
    def refinements(self, refinements):
        """Sets the refinements of this EmbeddedBoundaryMeshing.


        :param refinements: The refinements of this EmbeddedBoundaryMeshing.  # noqa: E501
        :type: list[OneOfEmbeddedBoundaryMeshingRefinements]
        """

        self._refinements = refinements

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, EmbeddedBoundaryMeshing):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, EmbeddedBoundaryMeshing):
            return True

        return self.to_dict() != other.to_dict()
