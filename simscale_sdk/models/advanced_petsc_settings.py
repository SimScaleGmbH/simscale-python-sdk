# coding: utf-8

"""
    SimScale API

    The version of the OpenAPI document: 0.0.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from simscale_sdk.configuration import Configuration


class AdvancedPETSCSettings(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'force_symmetric': 'bool',
        'algorithm': 'str',
        'preconditioner': 'OneOfAdvancedPETSCSettingsPreconditioner',
        'distributed_matrix_storage': 'bool'
    }

    attribute_map = {
        'force_symmetric': 'forceSymmetric',
        'algorithm': 'algorithm',
        'preconditioner': 'preconditioner',
        'distributed_matrix_storage': 'distributedMatrixStorage'
    }

    def __init__(self, force_symmetric=None, algorithm=None, preconditioner=None, distributed_matrix_storage=None, local_vars_configuration=None):  # noqa: E501
        """AdvancedPETSCSettings - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._force_symmetric = None
        self._algorithm = None
        self._preconditioner = None
        self._distributed_matrix_storage = None
        self.discriminator = None

        if force_symmetric is not None:
            self.force_symmetric = force_symmetric
        if algorithm is not None:
            self.algorithm = algorithm
        if preconditioner is not None:
            self.preconditioner = preconditioner
        if distributed_matrix_storage is not None:
            self.distributed_matrix_storage = distributed_matrix_storage

    @property
    def force_symmetric(self):
        """Gets the force_symmetric of this AdvancedPETSCSettings.  # noqa: E501

        Choose if you want to enforce a symmetric matrix.  # noqa: E501

        :return: The force_symmetric of this AdvancedPETSCSettings.  # noqa: E501
        :rtype: bool
        """
        return self._force_symmetric

    @force_symmetric.setter
    def force_symmetric(self, force_symmetric):
        """Sets the force_symmetric of this AdvancedPETSCSettings.

        Choose if you want to enforce a symmetric matrix.  # noqa: E501

        :param force_symmetric: The force_symmetric of this AdvancedPETSCSettings.  # noqa: E501
        :type: bool
        """

        self._force_symmetric = force_symmetric

    @property
    def algorithm(self):
        """Gets the algorithm of this AdvancedPETSCSettings.  # noqa: E501

        Choose the iterative solver method: <ul><li><p><b>FGMRES</b>: <i>Flexible Minimal Generalised RESidual</i>, best compromise between robustness and computational speed.</p></ul><ul><li><p><b>CG</b>: <i>Conjugate Gradient</i>, only useful for symmetric matrices</p></ul><ul><li><p><b>CR</b>: <i>Conjugate Residual</i>, only useful for symmetric matrices</p></ul><ul><li><p><b>GCR</b>: <i>Generalised Conjugate Residual</i>, treats general matrices</p></ul>All available methods are of <i>Krylov</i> type.  # noqa: E501

        :return: The algorithm of this AdvancedPETSCSettings.  # noqa: E501
        :rtype: str
        """
        return self._algorithm

    @algorithm.setter
    def algorithm(self, algorithm):
        """Sets the algorithm of this AdvancedPETSCSettings.

        Choose the iterative solver method: <ul><li><p><b>FGMRES</b>: <i>Flexible Minimal Generalised RESidual</i>, best compromise between robustness and computational speed.</p></ul><ul><li><p><b>CG</b>: <i>Conjugate Gradient</i>, only useful for symmetric matrices</p></ul><ul><li><p><b>CR</b>: <i>Conjugate Residual</i>, only useful for symmetric matrices</p></ul><ul><li><p><b>GCR</b>: <i>Generalised Conjugate Residual</i>, treats general matrices</p></ul>All available methods are of <i>Krylov</i> type.  # noqa: E501

        :param algorithm: The algorithm of this AdvancedPETSCSettings.  # noqa: E501
        :type: str
        """
        allowed_values = ["CG", "CR", "GCR", "GMRES"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and algorithm not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(algorithm, allowed_values)
            )

        self._algorithm = algorithm

    @property
    def preconditioner(self):
        """Gets the preconditioner of this AdvancedPETSCSettings.  # noqa: E501


        :return: The preconditioner of this AdvancedPETSCSettings.  # noqa: E501
        :rtype: OneOfAdvancedPETSCSettingsPreconditioner
        """
        return self._preconditioner

    @preconditioner.setter
    def preconditioner(self, preconditioner):
        """Sets the preconditioner of this AdvancedPETSCSettings.


        :param preconditioner: The preconditioner of this AdvancedPETSCSettings.  # noqa: E501
        :type: OneOfAdvancedPETSCSettingsPreconditioner
        """

        self._preconditioner = preconditioner

    @property
    def distributed_matrix_storage(self):
        """Gets the distributed_matrix_storage of this AdvancedPETSCSettings.  # noqa: E501

        Choose this parameter as <b>true</b> to ensure that the system matrix saving is distributed among the processors of the computation. If multiple cores are used only the relevant part for each core is saved. If it is set to false the whole matrix is saved for each processor. Enabling this can significantly reductions in memory consumption, but introduces numerical instability in rare occasions.  # noqa: E501

        :return: The distributed_matrix_storage of this AdvancedPETSCSettings.  # noqa: E501
        :rtype: bool
        """
        return self._distributed_matrix_storage

    @distributed_matrix_storage.setter
    def distributed_matrix_storage(self, distributed_matrix_storage):
        """Sets the distributed_matrix_storage of this AdvancedPETSCSettings.

        Choose this parameter as <b>true</b> to ensure that the system matrix saving is distributed among the processors of the computation. If multiple cores are used only the relevant part for each core is saved. If it is set to false the whole matrix is saved for each processor. Enabling this can significantly reductions in memory consumption, but introduces numerical instability in rare occasions.  # noqa: E501

        :param distributed_matrix_storage: The distributed_matrix_storage of this AdvancedPETSCSettings.  # noqa: E501
        :type: bool
        """

        self._distributed_matrix_storage = distributed_matrix_storage

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, AdvancedPETSCSettings):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, AdvancedPETSCSettings):
            return True

        return self.to_dict() != other.to_dict()
