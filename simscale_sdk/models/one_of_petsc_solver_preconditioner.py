# coding: utf-8

"""
    SimScale API

    The version of the OpenAPI document: 0.0.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from simscale_sdk.configuration import Configuration


class OneOfPETSCSolverPreconditioner(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'type': 'str',
        'actualisation_rate': 'int',
        'memory_percentage_for_pivoting': 'float',
        'matrix_completeness': 'int',
        'preconditioner_matrix_growth': 'float',
        'renumbering_method': 'str',
        'iterations_srqcg': 'int',
        'smoother': 'str',
        'prolongation': 'str',
        'recycling': 'float',
        'improve_test_space': 'bool',
        'test_space_iterations': 'int'
    }

    attribute_map = {
        'type': 'type',
        'actualisation_rate': 'actualisationRate',
        'memory_percentage_for_pivoting': 'memoryPercentageForPivoting',
        'matrix_completeness': 'matrixCompleteness',
        'preconditioner_matrix_growth': 'preconditionerMatrixGrowth',
        'renumbering_method': 'renumberingMethod',
        'iterations_srqcg': 'iterationsSRQCG',
        'smoother': 'smoother',
        'prolongation': 'prolongation',
        'recycling': 'recycling',
        'improve_test_space': 'improveTestSpace',
        'test_space_iterations': 'testSpaceIterations'
    }

    discriminator_value_class_map = {
        'MUMPS_LDLT': 'MUMPSPreconditoner',
        'INCOMPLETE_LDLT_V33': 'IncompletePreconditionerV33',
        'JACOBI': 'JacobiPreconditioner',
        'SOR': 'SorPreconditioner',
        'INACTIVE': 'InactivePreconditioner',
        'CHRONOS': 'ChronosPreconditioner'
    }

    def __init__(self, type='CHRONOS', actualisation_rate=None, memory_percentage_for_pivoting=None, matrix_completeness=None, preconditioner_matrix_growth=None, renumbering_method=None, iterations_srqcg=None, smoother=None, prolongation=None, recycling=None, improve_test_space=None, test_space_iterations=None, local_vars_configuration=None):  # noqa: E501
        """OneOfPETSCSolverPreconditioner - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._type = None
        self._actualisation_rate = None
        self._memory_percentage_for_pivoting = None
        self._matrix_completeness = None
        self._preconditioner_matrix_growth = None
        self._renumbering_method = None
        self._iterations_srqcg = None
        self._smoother = None
        self._prolongation = None
        self._recycling = None
        self._improve_test_space = None
        self._test_space_iterations = None
        self.discriminator = 'type'

        self.type = type
        if actualisation_rate is not None:
            self.actualisation_rate = actualisation_rate
        if memory_percentage_for_pivoting is not None:
            self.memory_percentage_for_pivoting = memory_percentage_for_pivoting
        if matrix_completeness is not None:
            self.matrix_completeness = matrix_completeness
        if preconditioner_matrix_growth is not None:
            self.preconditioner_matrix_growth = preconditioner_matrix_growth
        if renumbering_method is not None:
            self.renumbering_method = renumbering_method
        if iterations_srqcg is not None:
            self.iterations_srqcg = iterations_srqcg
        if smoother is not None:
            self.smoother = smoother
        if prolongation is not None:
            self.prolongation = prolongation
        if recycling is not None:
            self.recycling = recycling
        if improve_test_space is not None:
            self.improve_test_space = improve_test_space
        if test_space_iterations is not None:
            self.test_space_iterations = test_space_iterations

    @property
    def type(self):
        """Gets the type of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Schema name: ChronosPreconditioner  # noqa: E501

        :return: The type of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this OneOfPETSCSolverPreconditioner.

        Schema name: ChronosPreconditioner  # noqa: E501

        :param type: The type of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501

        self._type = type

    @property
    def actualisation_rate(self):
        """Gets the actualisation_rate of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Set the reactualisation intervall for the preconditioner matrix P. If this value is set to 30 the preconditioner is recomputed just every 30th iteration. This preconditioner is computionally more expensive than the incomplete LDLT factorization but nearer to the exact solution. This setting makes it possible to save computation time by taking advantage of this fact.  # noqa: E501

        :return: The actualisation_rate of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: int
        """
        return self._actualisation_rate

    @actualisation_rate.setter
    def actualisation_rate(self, actualisation_rate):
        """Sets the actualisation_rate of this OneOfPETSCSolverPreconditioner.

        Set the reactualisation intervall for the preconditioner matrix P. If this value is set to 30 the preconditioner is recomputed just every 30th iteration. This preconditioner is computionally more expensive than the incomplete LDLT factorization but nearer to the exact solution. This setting makes it possible to save computation time by taking advantage of this fact.  # noqa: E501

        :param actualisation_rate: The actualisation_rate of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: int
        """

        self._actualisation_rate = actualisation_rate

    @property
    def memory_percentage_for_pivoting(self):
        """Gets the memory_percentage_for_pivoting of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120.  # noqa: E501

        :return: The memory_percentage_for_pivoting of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: float
        """
        return self._memory_percentage_for_pivoting

    @memory_percentage_for_pivoting.setter
    def memory_percentage_for_pivoting(self, memory_percentage_for_pivoting):
        """Sets the memory_percentage_for_pivoting of this OneOfPETSCSolverPreconditioner.

        Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120.  # noqa: E501

        :param memory_percentage_for_pivoting: The memory_percentage_for_pivoting of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: float
        """

        self._memory_percentage_for_pivoting = memory_percentage_for_pivoting

    @property
    def matrix_completeness(self):
        """Gets the matrix_completeness of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Set the level of completeness for the incomplete Cholesky decomposition. The larger this value is, the better the preconditioning Matrix P approximates K<sup>-1</sup>, but also the memory usage and computation time increase. If the solution does not converge or uses a lot of iterations it could help to increase this parameter.  # noqa: E501

        :return: The matrix_completeness of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: int
        """
        return self._matrix_completeness

    @matrix_completeness.setter
    def matrix_completeness(self, matrix_completeness):
        """Sets the matrix_completeness of this OneOfPETSCSolverPreconditioner.

        Set the level of completeness for the incomplete Cholesky decomposition. The larger this value is, the better the preconditioning Matrix P approximates K<sup>-1</sup>, but also the memory usage and computation time increase. If the solution does not converge or uses a lot of iterations it could help to increase this parameter.  # noqa: E501

        :param matrix_completeness: The matrix_completeness of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: int
        """

        self._matrix_completeness = matrix_completeness

    @property
    def preconditioner_matrix_growth(self):
        """Gets the preconditioner_matrix_growth of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Set the growth rate of the filling for the incomplete decomposition matrix. If this parameter is set to 1.0 PETSc estimates the matrix storage size from the first level of completeness. If this estimate is too low, PETSC increases the allocated memory on the fly, but this is more expensive.  # noqa: E501

        :return: The preconditioner_matrix_growth of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: float
        """
        return self._preconditioner_matrix_growth

    @preconditioner_matrix_growth.setter
    def preconditioner_matrix_growth(self, preconditioner_matrix_growth):
        """Sets the preconditioner_matrix_growth of this OneOfPETSCSolverPreconditioner.

        Set the growth rate of the filling for the incomplete decomposition matrix. If this parameter is set to 1.0 PETSc estimates the matrix storage size from the first level of completeness. If this estimate is too low, PETSC increases the allocated memory on the fly, but this is more expensive.  # noqa: E501

        :param preconditioner_matrix_growth: The preconditioner_matrix_growth of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: float
        """

        self._preconditioner_matrix_growth = preconditioner_matrix_growth

    @property
    def renumbering_method(self):
        """Gets the renumbering_method of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Choose the renumbering method for the system matrix entries:<ul><li><p><b>RCMK</b> uses the algorithm of <i>Reverse Cuthill-MacKee</i> for the renumbering. It often effectively reduces the matrig storage space and the matrix factorization time.</p></ul><ul><li><p>When <b>inactive</b> is selected no renumbering is done. This option should only be chosen for testing purposes.</p></ul>  # noqa: E501

        :return: The renumbering_method of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: str
        """
        return self._renumbering_method

    @renumbering_method.setter
    def renumbering_method(self, renumbering_method):
        """Sets the renumbering_method of this OneOfPETSCSolverPreconditioner.

        Choose the renumbering method for the system matrix entries:<ul><li><p><b>RCMK</b> uses the algorithm of <i>Reverse Cuthill-MacKee</i> for the renumbering. It often effectively reduces the matrig storage space and the matrix factorization time.</p></ul><ul><li><p>When <b>inactive</b> is selected no renumbering is done. This option should only be chosen for testing purposes.</p></ul>  # noqa: E501

        :param renumbering_method: The renumbering_method of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: str
        """
        allowed_values = ["RCMK", "INACTIVE"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and renumbering_method not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `renumbering_method` ({0}), must be one of {1}"  # noqa: E501
                .format(renumbering_method, allowed_values)
            )

        self._renumbering_method = renumbering_method

    @property
    def iterations_srqcg(self):
        """Gets the iterations_srqcg of this OneOfPETSCSolverPreconditioner.  # noqa: E501


        :return: The iterations_srqcg of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: int
        """
        return self._iterations_srqcg

    @iterations_srqcg.setter
    def iterations_srqcg(self, iterations_srqcg):
        """Sets the iterations_srqcg of this OneOfPETSCSolverPreconditioner.


        :param iterations_srqcg: The iterations_srqcg of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: int
        """
        if (self.local_vars_configuration.client_side_validation and
                iterations_srqcg is not None and iterations_srqcg < 0):  # noqa: E501
            raise ValueError("Invalid value for `iterations_srqcg`, must be a value greater than or equal to `0`")  # noqa: E501

        self._iterations_srqcg = iterations_srqcg

    @property
    def smoother(self):
        """Gets the smoother of this OneOfPETSCSolverPreconditioner.  # noqa: E501


        :return: The smoother of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: str
        """
        return self._smoother

    @smoother.setter
    def smoother(self, smoother):
        """Sets the smoother of this OneOfPETSCSolverPreconditioner.


        :param smoother: The smoother of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: str
        """
        allowed_values = ["JACOBI", "FSAI_LIGHT", "FSAI_MEDIUM", "FSAI_HEAVY"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and smoother not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `smoother` ({0}), must be one of {1}"  # noqa: E501
                .format(smoother, allowed_values)
            )

        self._smoother = smoother

    @property
    def prolongation(self):
        """Gets the prolongation of this OneOfPETSCSolverPreconditioner.  # noqa: E501


        :return: The prolongation of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: str
        """
        return self._prolongation

    @prolongation.setter
    def prolongation(self, prolongation):
        """Sets the prolongation of this OneOfPETSCSolverPreconditioner.


        :param prolongation: The prolongation of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: str
        """
        allowed_values = ["UNSMOOTHED", "SMOOTHED", "ENERGY_MINIMIZATION"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and prolongation not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `prolongation` ({0}), must be one of {1}"  # noqa: E501
                .format(prolongation, allowed_values)
            )

        self._prolongation = prolongation

    @property
    def recycling(self):
        """Gets the recycling of this OneOfPETSCSolverPreconditioner.  # noqa: E501


        :return: The recycling of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: float
        """
        return self._recycling

    @recycling.setter
    def recycling(self, recycling):
        """Sets the recycling of this OneOfPETSCSolverPreconditioner.


        :param recycling: The recycling of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: float
        """
        if (self.local_vars_configuration.client_side_validation and
                recycling is not None and recycling > 1):  # noqa: E501
            raise ValueError("Invalid value for `recycling`, must be a value less than or equal to `1`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                recycling is not None and recycling < 0):  # noqa: E501
            raise ValueError("Invalid value for `recycling`, must be a value greater than or equal to `0`")  # noqa: E501

        self._recycling = recycling

    @property
    def improve_test_space(self):
        """Gets the improve_test_space of this OneOfPETSCSolverPreconditioner.  # noqa: E501


        :return: The improve_test_space of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: bool
        """
        return self._improve_test_space

    @improve_test_space.setter
    def improve_test_space(self, improve_test_space):
        """Sets the improve_test_space of this OneOfPETSCSolverPreconditioner.


        :param improve_test_space: The improve_test_space of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: bool
        """

        self._improve_test_space = improve_test_space

    @property
    def test_space_iterations(self):
        """Gets the test_space_iterations of this OneOfPETSCSolverPreconditioner.  # noqa: E501


        :return: The test_space_iterations of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: int
        """
        return self._test_space_iterations

    @test_space_iterations.setter
    def test_space_iterations(self, test_space_iterations):
        """Sets the test_space_iterations of this OneOfPETSCSolverPreconditioner.


        :param test_space_iterations: The test_space_iterations of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: int
        """
        if (self.local_vars_configuration.client_side_validation and
                test_space_iterations is not None and test_space_iterations < 0):  # noqa: E501
            raise ValueError("Invalid value for `test_space_iterations`, must be a value greater than or equal to `0`")  # noqa: E501

        self._test_space_iterations = test_space_iterations

    def get_real_child_model(self, data):
        """Returns the real base class specified by the discriminator"""
        discriminator_key = self.attribute_map[self.discriminator]
        discriminator_value = data[discriminator_key]
        return self.discriminator_value_class_map.get(discriminator_value)

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, OneOfPETSCSolverPreconditioner):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, OneOfPETSCSolverPreconditioner):
            return True

        return self.to_dict() != other.to_dict()
