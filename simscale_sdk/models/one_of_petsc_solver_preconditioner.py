# coding: utf-8

"""
    SimScale API

    The version of the OpenAPI document: 0.0.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from simscale_sdk.configuration import Configuration


class OneOfPETSCSolverPreconditioner(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'type': 'str',
        'actualisation_rate': 'int',
        'memory_percentage_for_pivoting': 'float',
        'matrix_completeness': 'int',
        'preconditioner_matrix_growth': 'float',
        'renumbering_method': 'str'
    }

    attribute_map = {
        'type': 'type',
        'actualisation_rate': 'actualisationRate',
        'memory_percentage_for_pivoting': 'memoryPercentageForPivoting',
        'matrix_completeness': 'matrixCompleteness',
        'preconditioner_matrix_growth': 'preconditionerMatrixGrowth',
        'renumbering_method': 'renumberingMethod'
    }

    discriminator_value_class_map = {
        'MUMPS_LDLT': 'MUMPSPreconditoner',
        'INCOMPLETE_LDLT': 'IncompletePreconditioner',
        'INCOMPLETE_LDLT_V33': 'IncompletePreconditionerV33',
        'JACOBI': 'JacobiPreconditioner',
        'SOR': 'SorPreconditioner',
        'INACTIVE': 'InactivePreconditioner'
    }

    def __init__(self, type='INACTIVE', actualisation_rate=None, memory_percentage_for_pivoting=None, matrix_completeness=0, preconditioner_matrix_growth=None, renumbering_method=None, local_vars_configuration=None):  # noqa: E501
        """OneOfPETSCSolverPreconditioner - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._type = None
        self._actualisation_rate = None
        self._memory_percentage_for_pivoting = None
        self._matrix_completeness = None
        self._preconditioner_matrix_growth = None
        self._renumbering_method = None
        self.discriminator = 'type'

        self.type = type
        if actualisation_rate is not None:
            self.actualisation_rate = actualisation_rate
        if memory_percentage_for_pivoting is not None:
            self.memory_percentage_for_pivoting = memory_percentage_for_pivoting
        self.matrix_completeness = matrix_completeness
        if preconditioner_matrix_growth is not None:
            self.preconditioner_matrix_growth = preconditioner_matrix_growth
        if renumbering_method is not None:
            self.renumbering_method = renumbering_method

    @property
    def type(self):
        """Gets the type of this OneOfPETSCSolverPreconditioner.  # noqa: E501


        :return: The type of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this OneOfPETSCSolverPreconditioner.


        :param type: The type of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501

        self._type = type

    @property
    def actualisation_rate(self):
        """Gets the actualisation_rate of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Set the reactualisation intervall for the preconditioner matrix P. If this value is set to 30 the preconditioner is recomputed just every 30th iteration. This preconditioner is computionally more expensive than the incomplete LDLT factorization but nearer to the exact solution. This setting makes it possible to save computation time by taking advantage of this fact.  # noqa: E501

        :return: The actualisation_rate of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: int
        """
        return self._actualisation_rate

    @actualisation_rate.setter
    def actualisation_rate(self, actualisation_rate):
        """Sets the actualisation_rate of this OneOfPETSCSolverPreconditioner.

        Set the reactualisation intervall for the preconditioner matrix P. If this value is set to 30 the preconditioner is recomputed just every 30th iteration. This preconditioner is computionally more expensive than the incomplete LDLT factorization but nearer to the exact solution. This setting makes it possible to save computation time by taking advantage of this fact.  # noqa: E501

        :param actualisation_rate: The actualisation_rate of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: int
        """

        self._actualisation_rate = actualisation_rate

    @property
    def memory_percentage_for_pivoting(self):
        """Gets the memory_percentage_for_pivoting of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120.  # noqa: E501

        :return: The memory_percentage_for_pivoting of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: float
        """
        return self._memory_percentage_for_pivoting

    @memory_percentage_for_pivoting.setter
    def memory_percentage_for_pivoting(self, memory_percentage_for_pivoting):
        """Sets the memory_percentage_for_pivoting of this OneOfPETSCSolverPreconditioner.

        Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120.  # noqa: E501

        :param memory_percentage_for_pivoting: The memory_percentage_for_pivoting of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: float
        """

        self._memory_percentage_for_pivoting = memory_percentage_for_pivoting

    @property
    def matrix_completeness(self):
        """Gets the matrix_completeness of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Set the level of completeness for the incomplete Cholesky decomposition. The larger this value is, the better the preconditioning Matrix P approximates K<sup>-1</sup>, but also the memory usage and computation time increase. If the solution does not converge or uses a lot of iterations it could help to increase this parameter.  # noqa: E501

        :return: The matrix_completeness of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: int
        """
        return self._matrix_completeness

    @matrix_completeness.setter
    def matrix_completeness(self, matrix_completeness):
        """Sets the matrix_completeness of this OneOfPETSCSolverPreconditioner.

        Set the level of completeness for the incomplete Cholesky decomposition. The larger this value is, the better the preconditioning Matrix P approximates K<sup>-1</sup>, but also the memory usage and computation time increase. If the solution does not converge or uses a lot of iterations it could help to increase this parameter.  # noqa: E501

        :param matrix_completeness: The matrix_completeness of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: int
        """
        if self.local_vars_configuration.client_side_validation and matrix_completeness is None:  # noqa: E501
            raise ValueError("Invalid value for `matrix_completeness`, must not be `None`")  # noqa: E501

        self._matrix_completeness = matrix_completeness

    @property
    def preconditioner_matrix_growth(self):
        """Gets the preconditioner_matrix_growth of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Set the growth rate of the filling for the incomplete decomposition matrix. If this parameter is set to 1.0 PETSc estimates the matrix storage size from the first level of completeness. If this estimate is too low, PETSC increases the allocated memory on the fly, but this is more expensive.  # noqa: E501

        :return: The preconditioner_matrix_growth of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: float
        """
        return self._preconditioner_matrix_growth

    @preconditioner_matrix_growth.setter
    def preconditioner_matrix_growth(self, preconditioner_matrix_growth):
        """Sets the preconditioner_matrix_growth of this OneOfPETSCSolverPreconditioner.

        Set the growth rate of the filling for the incomplete decomposition matrix. If this parameter is set to 1.0 PETSc estimates the matrix storage size from the first level of completeness. If this estimate is too low, PETSC increases the allocated memory on the fly, but this is more expensive.  # noqa: E501

        :param preconditioner_matrix_growth: The preconditioner_matrix_growth of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: float
        """

        self._preconditioner_matrix_growth = preconditioner_matrix_growth

    @property
    def renumbering_method(self):
        """Gets the renumbering_method of this OneOfPETSCSolverPreconditioner.  # noqa: E501

        Choose the renumbering method for the system matrix entries:<ul><li><p><b>RCMK</b> uses the algorithm of <i>Reverse Cuthill-MacKee</i> for the renumbering. It often effectively reduces the matrig storage space and the matrix factorization time.</p></ul><ul><li><p>When <b>inactive</b> is selected no renumbering is done. This option should only be chosen for testing purposes.</p></ul>  # noqa: E501

        :return: The renumbering_method of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :rtype: str
        """
        return self._renumbering_method

    @renumbering_method.setter
    def renumbering_method(self, renumbering_method):
        """Sets the renumbering_method of this OneOfPETSCSolverPreconditioner.

        Choose the renumbering method for the system matrix entries:<ul><li><p><b>RCMK</b> uses the algorithm of <i>Reverse Cuthill-MacKee</i> for the renumbering. It often effectively reduces the matrig storage space and the matrix factorization time.</p></ul><ul><li><p>When <b>inactive</b> is selected no renumbering is done. This option should only be chosen for testing purposes.</p></ul>  # noqa: E501

        :param renumbering_method: The renumbering_method of this OneOfPETSCSolverPreconditioner.  # noqa: E501
        :type: str
        """
        allowed_values = ["RCMK", "INACTIVE"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and renumbering_method not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `renumbering_method` ({0}), must be one of {1}"  # noqa: E501
                .format(renumbering_method, allowed_values)
            )

        self._renumbering_method = renumbering_method

    def get_real_child_model(self, data):
        """Returns the real base class specified by the discriminator"""
        discriminator_key = self.attribute_map[self.discriminator]
        discriminator_value = data[discriminator_key]
        return self.discriminator_value_class_map.get(discriminator_value)

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, OneOfPETSCSolverPreconditioner):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, OneOfPETSCSolverPreconditioner):
            return True

        return self.to_dict() != other.to_dict()
