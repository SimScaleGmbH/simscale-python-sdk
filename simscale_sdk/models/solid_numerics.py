# coding: utf-8

"""
    SimScale API

    The version of the OpenAPI document: 0.0.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from simscale_sdk.configuration import Configuration


class SolidNumerics(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'harmonic_solution_method': 'str',
        'solver': 'OneOfSolidNumericsSolver',
        'solve_model': 'object',
        'eigen_solver': 'OneOfSolidNumericsEigenSolver',
        'calculate_frequency': 'CalculateFrequency',
        'eigen_mode': 'EigenModeVerification',
        'enhanced_accuracy': 'bool',
        'modal_base': 'ModalSolver',
        'harmonic_response': 'HarmonicResponse',
        'mechanical_time_integration_type': 'OneOfSolidNumericsMechanicalTimeIntegrationType',
        'mechanical_resolution_type': 'OneOfSolidNumericsMechanicalResolutionType',
        'mechanical_line_search': 'OneOfSolidNumericsMechanicalLineSearch',
        'thermal_time_integration_type': 'ThetaMethodTimeIntegrationType',
        'thermal_resolution_type': 'OneOfSolidNumericsThermalResolutionType',
        'thermal_line_search': 'OneOfSolidNumericsThermalLineSearch'
    }

    attribute_map = {
        'harmonic_solution_method': 'harmonicSolutionMethod',
        'solver': 'solver',
        'solve_model': 'solveModel',
        'eigen_solver': 'eigenSolver',
        'calculate_frequency': 'calculateFrequency',
        'eigen_mode': 'eigenMode',
        'enhanced_accuracy': 'enhancedAccuracy',
        'modal_base': 'modalBase',
        'harmonic_response': 'harmonicResponse',
        'mechanical_time_integration_type': 'mechanicalTimeIntegrationType',
        'mechanical_resolution_type': 'mechanicalResolutionType',
        'mechanical_line_search': 'mechanicalLineSearch',
        'thermal_time_integration_type': 'thermalTimeIntegrationType',
        'thermal_resolution_type': 'thermalResolutionType',
        'thermal_line_search': 'thermalLineSearch'
    }

    def __init__(self, harmonic_solution_method=None, solver=None, solve_model=None, eigen_solver=None, calculate_frequency=None, eigen_mode=None, enhanced_accuracy=None, modal_base=None, harmonic_response=None, mechanical_time_integration_type=None, mechanical_resolution_type=None, mechanical_line_search=None, thermal_time_integration_type=None, thermal_resolution_type=None, thermal_line_search=None, local_vars_configuration=None):  # noqa: E501
        """SolidNumerics - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._harmonic_solution_method = None
        self._solver = None
        self._solve_model = None
        self._eigen_solver = None
        self._calculate_frequency = None
        self._eigen_mode = None
        self._enhanced_accuracy = None
        self._modal_base = None
        self._harmonic_response = None
        self._mechanical_time_integration_type = None
        self._mechanical_resolution_type = None
        self._mechanical_line_search = None
        self._thermal_time_integration_type = None
        self._thermal_resolution_type = None
        self._thermal_line_search = None
        self.discriminator = None

        if harmonic_solution_method is not None:
            self.harmonic_solution_method = harmonic_solution_method
        if solver is not None:
            self.solver = solver
        if solve_model is not None:
            self.solve_model = solve_model
        if eigen_solver is not None:
            self.eigen_solver = eigen_solver
        if calculate_frequency is not None:
            self.calculate_frequency = calculate_frequency
        if eigen_mode is not None:
            self.eigen_mode = eigen_mode
        if enhanced_accuracy is not None:
            self.enhanced_accuracy = enhanced_accuracy
        if modal_base is not None:
            self.modal_base = modal_base
        if harmonic_response is not None:
            self.harmonic_response = harmonic_response
        if mechanical_time_integration_type is not None:
            self.mechanical_time_integration_type = mechanical_time_integration_type
        if mechanical_resolution_type is not None:
            self.mechanical_resolution_type = mechanical_resolution_type
        if mechanical_line_search is not None:
            self.mechanical_line_search = mechanical_line_search
        if thermal_time_integration_type is not None:
            self.thermal_time_integration_type = thermal_time_integration_type
        if thermal_resolution_type is not None:
            self.thermal_resolution_type = thermal_resolution_type
        if thermal_line_search is not None:
            self.thermal_line_search = thermal_line_search

    @property
    def harmonic_solution_method(self):
        """Gets the harmonic_solution_method of this SolidNumerics.  # noqa: E501

        Select the basis for the computation of the harmonic analysis.  # noqa: E501

        :return: The harmonic_solution_method of this SolidNumerics.  # noqa: E501
        :rtype: str
        """
        return self._harmonic_solution_method

    @harmonic_solution_method.setter
    def harmonic_solution_method(self, harmonic_solution_method):
        """Sets the harmonic_solution_method of this SolidNumerics.

        Select the basis for the computation of the harmonic analysis.  # noqa: E501

        :param harmonic_solution_method: The harmonic_solution_method of this SolidNumerics.  # noqa: E501
        :type: str
        """
        allowed_values = ["MODAL_BASED", "DIRECT"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and harmonic_solution_method not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `harmonic_solution_method` ({0}), must be one of {1}"  # noqa: E501
                .format(harmonic_solution_method, allowed_values)
            )

        self._harmonic_solution_method = harmonic_solution_method

    @property
    def solver(self):
        """Gets the solver of this SolidNumerics.  # noqa: E501


        :return: The solver of this SolidNumerics.  # noqa: E501
        :rtype: OneOfSolidNumericsSolver
        """
        return self._solver

    @solver.setter
    def solver(self, solver):
        """Sets the solver of this SolidNumerics.


        :param solver: The solver of this SolidNumerics.  # noqa: E501
        :type: OneOfSolidNumericsSolver
        """

        self._solver = solver

    @property
    def solve_model(self):
        """Gets the solve_model of this SolidNumerics.  # noqa: E501


        :return: The solve_model of this SolidNumerics.  # noqa: E501
        :rtype: object
        """
        return self._solve_model

    @solve_model.setter
    def solve_model(self, solve_model):
        """Sets the solve_model of this SolidNumerics.


        :param solve_model: The solve_model of this SolidNumerics.  # noqa: E501
        :type: object
        """

        self._solve_model = solve_model

    @property
    def eigen_solver(self):
        """Gets the eigen_solver of this SolidNumerics.  # noqa: E501


        :return: The eigen_solver of this SolidNumerics.  # noqa: E501
        :rtype: OneOfSolidNumericsEigenSolver
        """
        return self._eigen_solver

    @eigen_solver.setter
    def eigen_solver(self, eigen_solver):
        """Sets the eigen_solver of this SolidNumerics.


        :param eigen_solver: The eigen_solver of this SolidNumerics.  # noqa: E501
        :type: OneOfSolidNumericsEigenSolver
        """

        self._eigen_solver = eigen_solver

    @property
    def calculate_frequency(self):
        """Gets the calculate_frequency of this SolidNumerics.  # noqa: E501


        :return: The calculate_frequency of this SolidNumerics.  # noqa: E501
        :rtype: CalculateFrequency
        """
        return self._calculate_frequency

    @calculate_frequency.setter
    def calculate_frequency(self, calculate_frequency):
        """Sets the calculate_frequency of this SolidNumerics.


        :param calculate_frequency: The calculate_frequency of this SolidNumerics.  # noqa: E501
        :type: CalculateFrequency
        """

        self._calculate_frequency = calculate_frequency

    @property
    def eigen_mode(self):
        """Gets the eigen_mode of this SolidNumerics.  # noqa: E501


        :return: The eigen_mode of this SolidNumerics.  # noqa: E501
        :rtype: EigenModeVerification
        """
        return self._eigen_mode

    @eigen_mode.setter
    def eigen_mode(self, eigen_mode):
        """Sets the eigen_mode of this SolidNumerics.


        :param eigen_mode: The eigen_mode of this SolidNumerics.  # noqa: E501
        :type: EigenModeVerification
        """

        self._eigen_mode = eigen_mode

    @property
    def enhanced_accuracy(self):
        """Gets the enhanced_accuracy of this SolidNumerics.  # noqa: E501

        Further increase the accuracy of the results by running two simulations. The results of the first one will be used as input for the second one to fine-tune the setup.  # noqa: E501

        :return: The enhanced_accuracy of this SolidNumerics.  # noqa: E501
        :rtype: bool
        """
        return self._enhanced_accuracy

    @enhanced_accuracy.setter
    def enhanced_accuracy(self, enhanced_accuracy):
        """Sets the enhanced_accuracy of this SolidNumerics.

        Further increase the accuracy of the results by running two simulations. The results of the first one will be used as input for the second one to fine-tune the setup.  # noqa: E501

        :param enhanced_accuracy: The enhanced_accuracy of this SolidNumerics.  # noqa: E501
        :type: bool
        """

        self._enhanced_accuracy = enhanced_accuracy

    @property
    def modal_base(self):
        """Gets the modal_base of this SolidNumerics.  # noqa: E501


        :return: The modal_base of this SolidNumerics.  # noqa: E501
        :rtype: ModalSolver
        """
        return self._modal_base

    @modal_base.setter
    def modal_base(self, modal_base):
        """Sets the modal_base of this SolidNumerics.


        :param modal_base: The modal_base of this SolidNumerics.  # noqa: E501
        :type: ModalSolver
        """

        self._modal_base = modal_base

    @property
    def harmonic_response(self):
        """Gets the harmonic_response of this SolidNumerics.  # noqa: E501


        :return: The harmonic_response of this SolidNumerics.  # noqa: E501
        :rtype: HarmonicResponse
        """
        return self._harmonic_response

    @harmonic_response.setter
    def harmonic_response(self, harmonic_response):
        """Sets the harmonic_response of this SolidNumerics.


        :param harmonic_response: The harmonic_response of this SolidNumerics.  # noqa: E501
        :type: HarmonicResponse
        """

        self._harmonic_response = harmonic_response

    @property
    def mechanical_time_integration_type(self):
        """Gets the mechanical_time_integration_type of this SolidNumerics.  # noqa: E501


        :return: The mechanical_time_integration_type of this SolidNumerics.  # noqa: E501
        :rtype: OneOfSolidNumericsMechanicalTimeIntegrationType
        """
        return self._mechanical_time_integration_type

    @mechanical_time_integration_type.setter
    def mechanical_time_integration_type(self, mechanical_time_integration_type):
        """Sets the mechanical_time_integration_type of this SolidNumerics.


        :param mechanical_time_integration_type: The mechanical_time_integration_type of this SolidNumerics.  # noqa: E501
        :type: OneOfSolidNumericsMechanicalTimeIntegrationType
        """

        self._mechanical_time_integration_type = mechanical_time_integration_type

    @property
    def mechanical_resolution_type(self):
        """Gets the mechanical_resolution_type of this SolidNumerics.  # noqa: E501


        :return: The mechanical_resolution_type of this SolidNumerics.  # noqa: E501
        :rtype: OneOfSolidNumericsMechanicalResolutionType
        """
        return self._mechanical_resolution_type

    @mechanical_resolution_type.setter
    def mechanical_resolution_type(self, mechanical_resolution_type):
        """Sets the mechanical_resolution_type of this SolidNumerics.


        :param mechanical_resolution_type: The mechanical_resolution_type of this SolidNumerics.  # noqa: E501
        :type: OneOfSolidNumericsMechanicalResolutionType
        """

        self._mechanical_resolution_type = mechanical_resolution_type

    @property
    def mechanical_line_search(self):
        """Gets the mechanical_line_search of this SolidNumerics.  # noqa: E501


        :return: The mechanical_line_search of this SolidNumerics.  # noqa: E501
        :rtype: OneOfSolidNumericsMechanicalLineSearch
        """
        return self._mechanical_line_search

    @mechanical_line_search.setter
    def mechanical_line_search(self, mechanical_line_search):
        """Sets the mechanical_line_search of this SolidNumerics.


        :param mechanical_line_search: The mechanical_line_search of this SolidNumerics.  # noqa: E501
        :type: OneOfSolidNumericsMechanicalLineSearch
        """

        self._mechanical_line_search = mechanical_line_search

    @property
    def thermal_time_integration_type(self):
        """Gets the thermal_time_integration_type of this SolidNumerics.  # noqa: E501


        :return: The thermal_time_integration_type of this SolidNumerics.  # noqa: E501
        :rtype: ThetaMethodTimeIntegrationType
        """
        return self._thermal_time_integration_type

    @thermal_time_integration_type.setter
    def thermal_time_integration_type(self, thermal_time_integration_type):
        """Sets the thermal_time_integration_type of this SolidNumerics.


        :param thermal_time_integration_type: The thermal_time_integration_type of this SolidNumerics.  # noqa: E501
        :type: ThetaMethodTimeIntegrationType
        """

        self._thermal_time_integration_type = thermal_time_integration_type

    @property
    def thermal_resolution_type(self):
        """Gets the thermal_resolution_type of this SolidNumerics.  # noqa: E501


        :return: The thermal_resolution_type of this SolidNumerics.  # noqa: E501
        :rtype: OneOfSolidNumericsThermalResolutionType
        """
        return self._thermal_resolution_type

    @thermal_resolution_type.setter
    def thermal_resolution_type(self, thermal_resolution_type):
        """Sets the thermal_resolution_type of this SolidNumerics.


        :param thermal_resolution_type: The thermal_resolution_type of this SolidNumerics.  # noqa: E501
        :type: OneOfSolidNumericsThermalResolutionType
        """

        self._thermal_resolution_type = thermal_resolution_type

    @property
    def thermal_line_search(self):
        """Gets the thermal_line_search of this SolidNumerics.  # noqa: E501


        :return: The thermal_line_search of this SolidNumerics.  # noqa: E501
        :rtype: OneOfSolidNumericsThermalLineSearch
        """
        return self._thermal_line_search

    @thermal_line_search.setter
    def thermal_line_search(self, thermal_line_search):
        """Sets the thermal_line_search of this SolidNumerics.


        :param thermal_line_search: The thermal_line_search of this SolidNumerics.  # noqa: E501
        :type: OneOfSolidNumericsThermalLineSearch
        """

        self._thermal_line_search = thermal_line_search

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SolidNumerics):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, SolidNumerics):
            return True

        return self.to_dict() != other.to_dict()
